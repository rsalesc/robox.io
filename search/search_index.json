{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"The go-to CLI tool for competitive programmers and setters. <p>rbx is a CLI tool and library that aims to help setters and contestants from the competitive programming community to have an easier time.</p> <p>Although trying to solve the issues of these two audiences seems to be too much for a single tool to handle, we exploit the fact that the journeys of setters and contestants have a lot in common.</p> <p>That's why rbx packages two CLI solutions: <code>rbx</code> (short for rbx for setters) and <code>rbc</code> (short for rbx for contestants).</p>"},{"location":"#features","title":"Features","text":"<p>For setters <code>rbx</code></p> <ul> <li>\ud83e\udd16 Generation: provides hooks for calling generators and generating testcases automatically.</li> <li>\ud83d\udd28 Testing: provides commands for automatically running correct and incorrect solutions against the testcases of your problem, automatically judging whether the verdict was as expected or not.</li> <li>\u2705 Verify: checks if your testcases and solutions are strictly conformant.</li> <li>\ud83d\udcdd Statements: provides tooling for writing and building statements.</li> <li>\ud83d\udce4 Package: provides a single command for packaging your problems for use in judge systems.</li> </ul> <p>For contestants <code>rbc</code></p> <ul> <li>\ud83e\udd16 Parsing: provides an entrypoint for contests and problems to be parsed through Competitive Companion.</li> <li>\ud83d\udd28 Testing: provides commands for automatically running your problems against both downloaded and manually added testcases, and shows a clear report.</li> <li>\ud83d\udce4 Submit: provides the option of submiting your solution for a few supported online judges from the command line.</li> <li>\ud83e\uddf1 Structure: provides an opinionated structure for the file tree of both parsed and manually created problems.</li> <li>\u2699\ufe0f Flexibility: still gives enough flexibility for you to extend your problem. Add testcases, set a custom checker, write a generator.</li> </ul> <p>Proceed to the Installation section.</p>"},{"location":"intro/configuration/","title":"Configuration","text":"<p>rbx is a best-effort zero-configuration tool. This means you should be able to run basic commands without touching any configuration file.</p> <p>If you want to dive deeper into rbx configuration files you can proceed to the Reference sections in the sidebar to understand each piece of configuration of the tool.</p> <p>If you want to start putting your hands on the tool and running a few commands, you can proceed to rbx First Steps (to start using rbx for setters) or to rbc First Steps (to start using rbx for contestants).</p>"},{"location":"intro/installation/","title":"Installation","text":"<p>You can install rbx with a single command, either using <code>pip</code> or <code>pipx</code>. Prefer using <code>pipx</code> to have a better isolation between the dependencies. Read more about <code>pipx</code> here.</p>"},{"location":"intro/installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.9 or above (stable with Python 3.10).</li> <li>A C++ toolchain to compile testlib libraries (usually <code>g++</code>).</li> <li>Optional:<ul> <li>Compilers/interpreters that you need to run your solutions on (e.g. <code>g++</code>, <code>java</code>).</li> <li>Competitive Companion for contestants</li> <li>pdfLaTeX and other additional packages to convert TeX files into PDF (see https://www.latex-project.org/get/)</li> </ul> </li> </ul>"},{"location":"intro/installation/#from-pypi","title":"From PyPI","text":"<pre><code>$ pipx install rbx.cp\n</code></pre>"},{"location":"intro/installation/#from-the-repository","title":"From the repository","text":"<pre><code>$ git clone https://github.com/rsalesc/rbx\n$ cd rbx\n$ pipx install .\n</code></pre>"},{"location":"intro/installation/#verify-installation","title":"Verify installation","text":"rbx --help# rbx help string should show up here <p>Proceed to the Configuration section.</p>"},{"location":"setters/cheatsheet/","title":"Cheatsheet","text":""},{"location":"setters/cheatsheet/#cli","title":"CLI","text":"Task Command Show help message <code>rbx --help</code> Create a new package in folder <code>package</code> <code>rbx create package</code> Compile a file given its path <code>rbx compile any my/file.cpp</code> Open the problem configuration in a text editor <code>rbx edit</code> Generate all testcases <code>rbx build</code> Generate all testcases and run validators <code>rbx verify</code> Run all solutions and check their tags <code>rbx run</code> Run all solutions except the slow ones <code>rbx run -v2</code> Run all solutions without checking <code>rbx run --nocheck</code> Run all solutions interactively <code>rbx irun</code> Run a stress test with name <code>break</code> <code>rbx stress break</code> Run a stress test for a generator <code>rbx stress gen -g \"[1..10]\" -s sols/main.cpp</code> Download testlib to the current folder <code>rbx download testlib</code> Download jngen to the current folder <code>rbx download jngen</code> Download a built-in testlib checker <code>rbx download checker wcmp.cpp</code> Build PDF statements <code>rbx statements build --output=pdf</code> Build PDF statements for English <code>rbx statements build en --output=pdf</code> Package problem for Polygon <code>rbx package polygon</code> Package problem for BOCA <code>rbx package boca</code> List all languages available in the environment <code>rbx languages</code> Clear cache <code>rbx clear</code>"},{"location":"setters/cheatsheet/#contest-cli","title":"Contest CLI","text":"Task Command Show help message <code>rbx contest --help</code> Create a new contest in folder <code>package</code> <code>rbx contest create package</code> Add a new problem to the contest with letter A <code>rbx contest add new-problem A</code> Open the contest configuration in a text editor <code>rbx contest edit</code> Build PDF statements <code>rbx contest statements build --output=pdf</code> Build PDF statements for English <code>rbx contest statements build en --output=pdf</code> Package contest for Polygon <code>rbx contest package polygon</code> Build each problem in the contest <code>rbx contest each build</code> Package each problem in the contest <code>rbx contest each package boca</code>"},{"location":"setters/cheatsheet/#problemrbxyml","title":"<code>problem.rbx.yml</code>","text":""},{"location":"setters/cheatsheet/#change-problem-constraints","title":"Change problem constraints","text":"<pre><code>timeLimit: 1000  # In milliseconds\nmemoryLimit: 256  # In megabytes\nmodifiers:\n  java:\n    time: 5000  # Override time for Java\n</code></pre>"},{"location":"setters/cheatsheet/#add-testlib-assets","title":"Add testlib assets","text":""},{"location":"setters/cheatsheet/#set-a-built-in-testlib-checker","title":"Set a built-in testlib checker","text":"<pre><code>rbx download checker yesno.cpp\n</code></pre> <pre><code>checker:\n  path: \"yesno.cpp\"\n</code></pre> <p>Tip</p> <p>Find here a full list of existing built-in testlib checkers.</p>"},{"location":"setters/cheatsheet/#set-a-custom-checker","title":"Set a custom checker","text":"<pre><code>checker:\n  path: \"my-checker.cpp\"\n</code></pre>"},{"location":"setters/cheatsheet/#add-a-generator","title":"Add a generator","text":"<p>Add a new generator entry to the <code>generators</code> field.</p> <pre><code>generators:\n  # ...other generators\n  - name: \"my-gen\"\n    path: \"my-gen.cpp\"\n</code></pre> <p>Tip</p> <p>To actually generate tests with this new generator, you have to add testcase groups and call the generator.</p>"},{"location":"setters/cheatsheet/#set-a-validator","title":"Set a validator","text":"<pre><code>validator:\n  path: 'my-validator.cpp`\n</code></pre>"},{"location":"setters/cheatsheet/#add-a-new-solution","title":"Add a new solution","text":"<p>Implement your solution (for instance, a wrong solution in <code>sols/my-wa-solution.cpp</code>) and add it to the <code>solutions</code> field.</p> <pre><code>solutions:\n  - path: 'sols/my-wa-solution.cpp'\n    outcome: WRONG_ANSWER\n</code></pre> <p>You can see the list of possible expected outcomes here.</p>"},{"location":"setters/cheatsheet/#add-testcases","title":"Add testcases","text":""},{"location":"setters/cheatsheet/#add-a-testcase-group-with-manually-defined-tests","title":"Add a testcase group with manually defined tests","text":"<pre><code>testcases:\n  # ...other testcase groups\n  - name: \"manual-tests\"\n    testcaseGlob: \"tests/manual/*.in\" # (1)!\n</code></pre> <ol> <li> <p>Import all tests in the <code>tests/manual/</code> folder in lexicographic order.</p> <p>The test input files must end in <code>.in</code>.</p> </li> </ol>"},{"location":"setters/cheatsheet/#add-a-testcase-group-with-a-list-of-generated-tests","title":"Add a testcase group with a list of generated tests","text":"<pre><code>testcases:\n  # ...other testcase groups\n  - name: \"single-generated\"\n    generators:\n      - name: \"gen\"\n        args: \"1000 123\" # (1)!\n      - name: \"gen\"\n        args: \"1000 456\" # (2)!\n</code></pre> <ol> <li>A generated test obtained from the output of the command <code>gen 1000 123</code>.</li> <li>A generated test obtained from the output of the command <code>gen 1000 456</code>.</li> </ol>"},{"location":"setters/cheatsheet/#add-a-testcase-group-with-a-list-of-generated-tests-from-a-generator-script","title":"Add a testcase group with a list of generated tests from a generator script","text":"problem.rbx.ymlscript.txt <pre><code>testcases:\n  # ...other testcase groups\n   - name: \"generated-from-text-script\"\n     generatorScript:\n        path: \"script.txt\"\n</code></pre> <pre><code>gen 1000 123\ngen 1000 456\ngen 1000 789\n# other tests...\n</code></pre>"},{"location":"setters/cheatsheet/#add-a-testcase-group-with-a-list-of-generated-tests-from-a-dynamic-generator-script","title":"Add a testcase group with a list of generated tests from a dynamic generator script","text":"problem.rbx.ymlscript.py <pre><code>testcases:\n  # ...other testcase groups\n   - name: \"generated-from-program-script\"\n     generatorScript:\n        path: \"script.py\"\n</code></pre> <pre><code>for i in range(50):\n  print(f'gen 1000 {i}') # (1)!\n</code></pre> <ol> <li>Generates 50 random tests.</li> </ol>"},{"location":"setters/cheatsheet/#add-testgroup-specific-validator","title":"Add testgroup-specific validator","text":"<pre><code>validator:\n  path: \"my-validator.cpp\"\ntestcases:\n  - name: \"small-group\"\n    # Define tests...\n    validator:\n      path: \"my-small-validator.cpp\" # (1)!\n  - name: \"large-group\"\n    # Define tests...\n</code></pre> <ol> <li>Add a specific validator to verify constraints of a smaller sub-task of the problem.</li> </ol>"},{"location":"setters/cheatsheet/#add-variables","title":"Add variables","text":"<p>The variables below can be reused across validators and statements.</p> <pre><code>vars:\n  \"MAX_N\": 1000\n  \"MAX_V\": 100000\n  \"MOD\": py`10**9+7` # Backticks force the var to be evaluated as a Python expression.\n</code></pre>"},{"location":"setters/cheatsheet/#use-variables","title":"Use variables","text":"In validatorsIn statements <pre><code>int32_t main() {\n  registerValidation(argc, argv);\n  prepareOpts(argc, argv);\n\n  int MAX_N = opt&lt;int&gt;(\"MAX_N\"); // Read from package vars.\n\n  // Rest of the validator\n}\n</code></pre> <pre><code>The maximum value of N is \\VAR{MAX_N | sci} % (1)!\n</code></pre> <ol> <li>If <code>MAX_N</code> has lots of trailing zeroes, <code>sci</code> converts it to scientific notation.</li> </ol>"},{"location":"setters/cheatsheet/#add-statements","title":"Add statements","text":""},{"location":"setters/cheatsheet/#add-a-rbxtex-statement","title":"Add a rbxTeX statement","text":"<pre><code>statements:\n  # ...other statements\n  - title: \"My problem\"\n    path: \"statement/statement.rbx.tex\"\n    type: rbxTeX\n    language: 'en'\n    pipeline:\n      - type: 'rbx-tex'\n        template: statement/template.rbx.tex' # (1)!\n    assets: ['statement/olymp.sty', 'statement/*.png'] # (2)!\n</code></pre> <ol> <li> <p>Defines how a rbxTeX file will be converted to a normal TeX file. Here, we link      the template where our rbxTeX sections such as legend, input and output      will be inserted into.</p> </li> <li> <p>Defines assets that should be linked when the resulting statement is being compiled.</p> </li> </ol>"},{"location":"setters/cheatsheet/#add-a-pdf-statement","title":"Add a PDF statement","text":"<pre><code>statements:\n  # ...other statements\n  - title: \"My problem\"\n    path: \"statement/statement.pdf\"\n    type: PDF\n    language: 'en'\n</code></pre>"},{"location":"setters/cheatsheet/#add-a-stress-test","title":"Add a stress test","text":""},{"location":"setters/cheatsheet/#add-a-stress-to-look-for-an-error-in-a-solution","title":"Add a stress to look for an error in a solution","text":"<pre><code>stresses:\n  - name: \"my-stress\"\n    generator:\n      name: 'gen'\n      args: '[1..&lt;MAX_N&gt;] @' # (1)!\n    finder: \"[sols/my-wa-solution.cpp] ~ INCORRECT\" # (2)!\n</code></pre> <ol> <li> <p>The <code>&lt;MAX_N&gt;</code> variable expands into the <code>vars.MAX_N</code> value that could be declared in     <code>problem.rbx.yml</code>.</p> <p>The <code>[1..&lt;MAX_N&gt;]</code> picks a random number in this interval before generating every test in the stress run.</p> <p>The <code>@</code> appends a few extra random characters to the end of the generator call to re-seed the generator.</p> </li> <li> <p>Expression that refers to solution <code>sols/my-wa-solution.cpp</code> and check whether it returns an incorrect outcome.</p> </li> </ol>"},{"location":"setters/cheatsheet/#add-a-stress-to-look-for-a-test-that-causes-tle-in-a-solution","title":"Add a stress to look for a test that causes TLE in a solution","text":"<pre><code>stresses:\n  - name: \"my-stress\"\n    generator:\n      name: 'gen'\n      args: '1000000 @' # (1)!\n    finder: \"[sols/my-potentially-slow-sol.cpp] ~ TLE\"\n</code></pre> <ol> <li>The <code>@</code> at the end of the <code>args</code> string appends a random string to it. This is necessary here because <code>gen 100000</code> would return the same testcase over and over, since testlib rng is seeded from its command line argc and argv.</li> </ol>"},{"location":"setters/cheatsheet/#contestrbxyml","title":"<code>contest.rbx.yml</code>","text":""},{"location":"setters/cheatsheet/#add-a-new-problem","title":"Add a new problem","text":"<pre><code>problems:\n  - short_name: \"A\"  # Letter of the problem\n    path: \"problem_folder\"\n    color: \"ff0000\"  # Optional\n</code></pre>"},{"location":"setters/first-steps/","title":"First steps","text":"<p><code>rbx</code> (short for rbx for setters) is the CLI tool rbx provides for setters to prepare contests and problems.</p> <p>You can start creating a new problem from a pre-initialized template by running <code>rbx create [name]</code>.</p> rbx create test# This will create a `test` directory under the current# working directory with a pre-initialized problem template. <p>This is how the directory structure of the pre-initialized problem template will look like:</p> <pre><code>test\n\u251c\u2500\u2500 sols  # (1)!\n\u2502   \u251c\u2500\u2500 main.cpp\n\u2502   \u251c\u2500\u2500 slow.cpp\n\u2502   \u2514\u2500\u2500 wa.cpp\n\u251c\u2500\u2500 statement  # (2)!\n\u2502   \u251c\u2500\u2500 olymp.sty\n\u2502   \u251c\u2500\u2500 projecao.png\n\u2502   \u251c\u2500\u2500 statement.rbx.tex\n\u2502   \u2514\u2500\u2500 template.rbx.tex\n\u251c\u2500\u2500 tests  # (3)!\n\u2502   \u2514\u2500\u2500 samples\n\u2502       \u251c\u2500\u2500 000.in\n\u2502       \u2514\u2500\u2500 001.in\n\u251c\u2500\u2500 gen.cpp # (4)!\n\u251c\u2500\u2500 problem.rbx.yml # (5)!\n\u251c\u2500\u2500 random.txt # (6)!\n\u251c\u2500\u2500 random.py # (7)!\n\u251c\u2500\u2500 validator.cpp # (8)!\n\u2514\u2500\u2500 wcmp.cpp # (9)!\n</code></pre> <ol> <li>All solutions for the problem: the correct and the incorrect ones.</li> <li>All statement-related assets, including the legend of the problem itself     but also the tex templates and imported graphics.</li> <li> <p>Manually defined tests of the problem.</p> <p>Note</p> <p>Automatically generated tests are not defined by explicit input and output files, but are rather defined by generator entries in the problem configuration.</p> </li> <li> <p>An example of a testlib generator. In this case, the generator is used to     generate testcases for two testgroups: <code>random</code> and <code>program-random</code>.</p> <p>Note</p> <p>A problem can have multiple generators. This one is just an example.</p> </li> <li> <p>The YAML configuration file for this problem.</p> </li> <li> <p>A generator script for the problem.</p> <p>Each line of a generator script describes one call to a generator, and a generator script groups all these calls together.</p> <p>Example:</p> <pre><code>gen 123\ngen 456\n</code></pre> <p>Calls the generator named <code>gen</code> (here in this problem, implemented through <code>gen.cpp</code>) twice, thus generating two testcases.</p> <p>In this problem, this script is used to generate the testcase group <code>random</code>.</p> </li> <li> <p>A program that outputs a generator script. Pretty similar to <code>random.txt</code>     above, except that this is a program that prints to the stdout a     generator script, and thus provides more flexibility to the setter.</p> <p>Example:</p> <pre><code>#! /usr/bin/python3\nfor i in range(10):\n    print(f'gen {i}')\n</code></pre> <p>This program outputs a generator script that creates 10 testcases with increasing parameter <code>i</code>.</p> <p>In this problem, this program is used to generate the testcase group <code>program-random</code>.</p> </li> <li> <p>A testlib validator that checks whether the generated tests are     in the correct format.</p> </li> <li> <p>A built-in testlib checker that compares tokens of the participant's output     and the judge's output.</p> </li> </ol>"},{"location":"setters/first-steps/#build","title":"Build","text":"<p>Let's skip the configuration of the problem for a second, and just build and run it. You can build a problem with {{ no such element: str object['build'] }}. This will populate a <code>build</code> folder inside your problem's folder with all the testcases generated for the problem.</p> <pre><code>$ rbx build\n$ ls build\nbuild\n\u2502   \u2514\u2500\u2500 tests\n\u2502       \u251c\u2500\u2500 program-random\n\u2502       \u2502   \u2514\u2500\u2500 ...\n\u2502       \u251c\u2500\u2500 random\n\u2502       \u2502   \u2514\u2500\u2500 ...\n\u2502       \u2514\u2500\u2500 samples\n\u2502           \u2514\u2500\u2500 ...\n</code></pre> <p>You can notice it created several folders inside a <code>tests</code> directory, each of which contains the tests for a specific testgroup. For this template in particular, we have three testsets: <code>random</code>, <code>program-random</code> and <code>samples</code>. We'll go into more details about each one of these in a minute.</p>"},{"location":"setters/first-steps/#run","title":"Run","text":"<p>Now, let's execute <code>rbx run</code>. This command builds all testcases and executes each solution against them, evaluating whether each solution had the expected outcome.</p> <pre><code>$ rbx run\n</code></pre> <p>You can see this command prints a full run report: it shows for each testcase of each testgroup whether a certain solution passed or not. There are also links for the outputs of each problem.</p> <p>Tip</p> <p>You can notice when you called <code>rbx run</code>, the testcases were built really fast. That's because rbx caches certain calls based on the hash tree of your package (similar to Makefile). You can explicitly clear this cache by calling <code>rbx clean</code>.</p> Result of the `rbx run` command."},{"location":"setters/first-steps/#modifying-the-package","title":"Modifying the package","text":"<p>As you can see from the solutions and the statement, the pre-initialized template simply implements a problem where you have to add up two numbers <code>A</code> and <code>B</code>. Let's modify the problem to compute the sum of N numbers.</p>"},{"location":"setters/first-steps/#rewrite-solutions","title":"Rewrite solutions","text":"<p>Let's start rewriting the solutions. We can probably drop the slow solution since we're just naively summing numbers anyway.</p> <p>We can develop the following accepted and wrong answer solutions.</p> sols/main.cppsols/wa.cpp <pre><code>#include &lt;bits/stdc++.h&gt;\n\nint32_t main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int64_t ans = 0;\n    for(int i = 0; i &lt; n; i++) {\n        int x;\n        cin &gt;&gt; x;\n        ans += x;\n    }\n\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n</code></pre> <pre><code>#include &lt;bits/stdc++.h&gt;\n\nint32_t main() {\n    int n;\n    cin &gt;&gt; n;\n\n    int32_t ans = 0; // int32 overflows!!\n    for(int i = 0; i &lt; n; i++) {\n        int x;\n        cin &gt;&gt; x;\n        ans += x;\n    }\n\n    cout &lt;&lt; ans &lt;&lt; endl;\n}\n</code></pre> <p>To delete the <code>slow.cpp</code> solution from our package, we can just delete the file and the reference to it in <code>problem.rbx.yml</code>. The reference is located in the <code>solutions</code> section, which will look like this after the deletion:</p> <pre><code>solutions:\n  - path: 'sols/main.cpp'\n    outcome: ACCEPTED\n  - path: 'sols/wa.cpp'\n    outcome: WRONG_ANSWER\n</code></pre> <p>You can find the full list of expected outcomes here.</p>"},{"location":"setters/first-steps/#write-the-validator","title":"Write the validator","text":"<p>The testlib validator is implemented by <code>validator.cpp</code> and will look like this:</p> validator.cpp <pre><code>#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    prepareOpts(argc, argv);\n\n    int MAX_N = opt&lt;int&gt;(\"MAX_N\"); // (1)!\n\n    for (int i = 0; i &lt; n; i++) {\n        if (i) inf.readSpace();\n        inf.readInt(1, MAX_N, \"A_i\");\n    }\n    inf.readEoln();\n    inf.readEof();\n}\n</code></pre> <ol> <li><code>MAX_N</code> is a variable defined in <code>problem.rbx.yaml</code> that is accessible     in the validator. It allows you to change the constraints of the problem,     and instantly replicate the change in validators and statements.</li> </ol>"},{"location":"setters/first-steps/#generating-random-testcases","title":"Generating random testcases","text":"<p>Now, let's rewrite our random generator to generate <code>N</code> numbers instead of only two.</p> <p>We have to actually call this generator and generate testcases into some of the testgroups.</p> <p>Let's delete the existing test groups in <code>problem.rbx.yml</code>, except for the <code>samples</code> one, and create a new <code>main_tests</code> group. Let's generate 10 random tests for this group by using a generator script. We can end up with the following files:</p> gen.cpprandom.pyproblem.rbx.yml <pre><code>#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerGen(argc, argv, 1); // (1)!\n\n    int n = rnd.next(1, opt&lt;int&gt;(1));\n\n    for (int i = 0; i &lt; n; i++) {\n        if (i) cout &lt;&lt; \" \";\n        cout &lt;&lt; rnd.next(1, opt&lt;int&gt;(2));\n    }\n    cout &lt;&lt; endl;\n}\n</code></pre> <ol> <li>The generator now receive two parameters <code>MAX_N</code> (accessed through <code>opt&lt;int&gt;(1)</code>) and <code>MAX_A</code> (accessed through <code>opt&lt;int&gt;(2)</code>).</li> </ol> <pre><code>for i in range(10):\n    print(f'gen 1000 1000000000 {i}') # (1)!\n</code></pre> <ol> <li> <p>This line defines 10 random calls to the generator <code>gen</code>,      which will in turn generate testcases with <code>N</code> randomly varying     from 1 to 1000 and the numbers to be added varying from 1 to <code>1e9</code>.</p> <p>Tip</p> <p>Notice the trailing <code>{i}</code> being printed in every generator script line. That's because testlib rng seed is initialized from the <code>argv</code> given to the generator.</p> <p>Thus generators are reproducible: if we called <code>gen 1000</code> 10 times, we would always get the same result. By appending an extra variable <code>{i}</code>, we introduce randomness to the tests.</p> </li> </ol> <pre><code># Testcases section would look like:\n\ntestcases:\n- name: 'samples'\n    testcaseGlob: 'tests/samples/*.in'\n- name: 'main_tests'  # (1)!\n    generatorScript:\n        path: 'random.py'\n</code></pre> <ol> <li>Here, <code>main_tests</code> would contain the 10 tests defined in <code>random.py</code>.</li> </ol> <p>Now, if we run <code>rbx build</code>, we'd get our brand new generated tests.</p>"},{"location":"setters/first-steps/#update-the-statement","title":"Update the statement","text":"<p>Of course, last but not least, we have to update the statement of our problem. rbx has its own statement format, called rbxTeX.</p> <p>In <code>statement/statement.rbx.tex</code> you will find something like the following:</p> statement/statement.rbx.tex <pre><code>%- block legend\nDado dois n\u00fameros inteiros $A$ e $B$, determine o valor de $A + B$.\n\n\\includegraphics[width=6cm]{projecao.png}\n%- endblock\n\n%- block input\nA entrada \u00e9 composta por uma \u00fanica linha contendo dois n\u00fameros\ninteiros $A$ e $B$ ($1 \\leq A, B \\leq \\VAR{vars.MAX_N | sci}$). % (1)!\n%- endblock\n\n%- block output\nA sa\u00edda deve conter somente um \u00fanico inteiro, a soma de $A$ e $B$.\n%- endblock\n\n%- block notes\nSem muitas notas pra este problema.\n%- endblock\n</code></pre> <ol> <li> <p>Notice the use of <code>\\VAR</code> here, which is a command rbxTeX exposes for     you to access variables defined in <code>problem.rbx.yml</code>, similar to how you     accessed these in the testlib validator.</p> <p>The template engine used to expand <code>\\VAR{...}</code> is Jinja2. This means we can also use filters. Here in particular, we're using a pre-defined filter implemented by rbxTeX called <code>sci</code>. This filter converts numbers with lots of zeroes (for instance, 100000), into their scientific notations (<code>10^5</code>).</p> </li> </ol> <p>As you can see, similar to Polygon, you write a few blocks of LaTeX that are expanded into a template. Here, the <code>%</code> delimits those pre-defined blocks. Your statement needs at least a legend, an input and an output.</p> <p>Let's change each corresponding block to match our new problem description.</p> statement/statement.rbx.tex <pre><code>%- block legend\nGiven $N$ integers, print their sum.\n%- endblock\n\n%- block input\nThe input has a single line containing $N$ \n($1 \\leq N \\leq \\VAR{vars.MAX_N | sci}$) numbers. \nThese numbers range from 1 to $\\VAR{vars.MAX_A | sci}$.\n%- endblock\n\n%- block output\nPrint the sum of the integers.\n%- endblock\n\n%- block notes\nNo notes.\n%- endblock\n</code></pre>"},{"location":"setters/first-steps/#advanced-configuration","title":"Advanced configuration","text":"<p>If you want to do more advanced changes to the package, you can continue reading our Reference section on the sidebar.</p>"},{"location":"setters/first-steps/#package-the-problem","title":"Package the problem","text":"<p>To build you problem, you can use the <code>rbx package [platform]</code> command.</p> <p>Here, we'll build a Polygon package with our statement, and as such we'll need LaTeX dependencies installed to compile it to a PDF. You can read more about a few recommendations we have to install pdfLaTeX and other common dependencies here.</p> <p>Note</p> <p>Packages usually require a statement to be built.</p> <p>You can try running <code>rbx package [platform] --no-statement</code>, but an error might be raised in case such platform does not support packages without statements.</p> <pre><code>$ rbx package polygon\n</code></pre> <p>A Polygon package will be built. This package can be directly uploaded to the Codeforces Gym through FTP.</p>"},{"location":"setters/reference/cli/","title":"CLI","text":"<p>TODO</p>"},{"location":"setters/reference/environment/","title":"Environment","text":"<p>TODO</p>"},{"location":"setters/reference/contest/","title":"Contest package","text":"<p>This documentation goes over how each field (or group of fields) in <code>contest.rbx.yml</code> works.</p>"},{"location":"setters/reference/contest/#contest-definition","title":"Contest definition","text":"<p>Schema: rbx.box.contest.schema.Contest</p> <p>The only required field of a contest is its <code>name</code>.</p> <p>A barebones package would look something like:</p> <pre><code>name: \"my-problem\"\n</code></pre>"},{"location":"setters/reference/contest/#contest-problem","title":"Contest problem","text":"<p>Schema: <code>List[</code><code>ContestProblem</code><code>]</code></p> <pre><code>name: \"my-contest\"\nproblems:\n  - short_name: \"A\"\n    path: \"A\"\n    color: \"ff0000\"\n  - short_name: \"B\"\n    path: \"B\"\n    color: \"00ff00\"\n</code></pre>"},{"location":"setters/reference/contest/schema/","title":"Contest schema","text":""},{"location":"setters/reference/contest/schema/#contestrbxyml","title":"<code>contest.rbx.yml</code>","text":""},{"location":"setters/reference/contest/schema/#rbx.box.contest.schema.Contest","title":"<code>Contest</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of this contest.</p> required <code>problems</code> <code>List[ContestProblem]</code> <p>List of problems in this contest.</p> <code>[]</code> <code>statements</code> <code>List[ContestStatement]</code> <p>Configure statements in this contest, per language.</p> <code>None</code> <code>vars</code> <code>Dict[str, Union[str, int, float, bool]]</code> <p>Variables to be re-used across the package.</p> <code>{}</code> Source code in <code>rbx/box/contest/schema.py</code> <pre><code>class Contest(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = NameField(description='Name of this contest.')\n\n    problems: List[ContestProblem] = Field(\n        default=[], description='List of problems in this contest.'\n    )\n\n    statements: List[ContestStatement] = Field(\n        default=None,\n        description='Configure statements in this contest, per language.',\n    )\n\n    # Vars to be re-used in the statements.\n    #   - It will be available as \\VAR{vars} variable in the contest-level box statement.\n    vars: Dict[str, Primitive] = Field(\n        {}, description='Variables to be re-used across the package.'\n    )\n\n    @property\n    def expanded_vars(self) -&gt; Dict[str, Primitive]:\n        return {key: expand_var(value) for key, value in self.vars.items()}\n</code></pre>"},{"location":"setters/reference/contest/schema/#rbx.box.contest.schema.ContestProblem","title":"<code>ContestProblem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>short_name</code> <code>str</code> <p>Short name of the problem. Usually, just an uppercase letter, but can be a sequence of uppercase letters followed by a number.</p> required <code>path</code> <code>Path | None</code> <p>Path to the problem relative to the contest package directory. If not specified, will expect the problem to be in ./{short_name}/ folder.</p> <code>None</code> <code>color</code> <code>str | None</code> <p>Hex-based color that represents this problem in the contest.</p> <code>None</code> Source code in <code>rbx/box/contest/schema.py</code> <pre><code>class ContestProblem(BaseModel):\n    short_name: str = ShortNameField(\n        description=\"\"\"\nShort name of the problem. Usually, just an uppercase letter,\nbut can be a sequence of uppercase letters followed by a number.\"\"\"\n    )\n    path: Optional[pathlib.Path] = Field(\n        default=None,\n        description=\"\"\"\nPath to the problem relative to the contest package directory.\nIf not specified, will expect the problem to be in ./{short_name}/ folder.\"\"\",\n    )\n\n    color: Optional[str] = Field(\n        default=None,\n        description=\"\"\"Hex-based color that represents this problem in the contest.\"\"\",\n        pattern=r'^[A-Za-z0-9]+$',\n        max_length=6,\n    )\n\n    def get_path(self) -&gt; pathlib.Path:\n        return self.path or pathlib.Path(self.short_name)\n</code></pre>"},{"location":"setters/reference/contest/schema/#rbx.box.contest.schema.ContestStatement","title":"<code>ContestStatement</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>language</code> <code>str</code> <p>Language code for this statement.</p> <code>'en'</code> <code>title</code> <code>str</code> <p>Title of the contest in this language.</p> required <code>location</code> <code>str | None</code> <p>Location of the contest in this language.</p> <code>None</code> <code>date</code> <code>str | None</code> <p>Date of the contest in this language.</p> <code>None</code> <code>path</code> <code>Path</code> <p>Path to the input statement file.</p> required <code>type</code> <code>StatementType</code> <p>Type of the input statement file.</p> required <code>joiner</code> <code>JoinTexToPDF | None</code> <p>Joiner to be used to build the statement.</p> <p>This determines how problem statements will be joined into a single contest statement.</p> <code>None</code> <code>steps</code> <code>List[Union[TexToPDF, JinjaTeX, rbxToTeX]]</code> <p>Describes a sequence of conversion steps that should be applied to the statement file of this contest.</p> <p>Usually, it is not necessary to specify these, as they can be inferred from the input statement type and the output statement type, but you can use this to force certain conversion steps to happen.</p> <code>[]</code> <code>configure</code> <code>List[Union[TexToPDF, JinjaTeX, rbxToTeX]]</code> <p>Configure how certain conversion steps should happen when applied to the statement file of this contest.</p> <p>Different from the <code>steps</code> field, this does not force the steps to happen, but rather only configure them in case they are applied.</p> <code>[]</code> <code>assets</code> <code>List[str]</code> <p>Assets relative to the contest directory that should be included while building the statement. Files will be included in the same folder as the statement file. Can be glob pattern as well, such as <code>imgs/*.png</code>.</p> <code>[]</code> <code>override</code> <code>ProblemStatementOverride | None</code> <p>Override configuration for problem statements.</p> <code>None</code> <code>vars</code> <code>Dict[str, Union[str, int, float, bool]]</code> <p>Variables to be re-used across the package.</p> <code>{}</code> Source code in <code>rbx/box/contest/schema.py</code> <pre><code>class ContestStatement(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    language: str = Field('en', description='Language code for this statement.')\n\n    title: str = Field(description='Title of the contest in this language.')\n\n    location: Optional[str] = Field(\n        default=None, description='Location of the contest in this language.'\n    )\n\n    date: Optional[str] = Field(\n        default=None, description='Date of the contest in this language.'\n    )\n\n    path: pathlib.Path = Field(description='Path to the input statement file.')\n\n    type: StatementType = Field(description='Type of the input statement file.')\n\n    joiner: Optional[Joiner] = Field(\n        None,\n        description=\"\"\"\nJoiner to be used to build the statement.\n\nThis determines how problem statements will be joined into a single contest statement.\"\"\",\n    )\n\n    steps: List[ConversionStep] = Field(\n        default=[],\n        discriminator='type',\n        description=\"\"\"\nDescribes a sequence of conversion steps that should be applied to the statement file\nof this contest.\n\nUsually, it is not necessary to specify these, as they can be inferred from the\ninput statement type and the output statement type, but you can use this to force\ncertain conversion steps to happen.\n\"\"\",\n    )\n\n    configure: List[ConversionStep] = Field(\n        default=[],\n        discriminator='type',\n        description=\"\"\"\nConfigure how certain conversion steps should happen when applied to the statement file of\nthis contest.\n\nDifferent from the `steps` field, this does not force the steps to happen, but rather only\nconfigure them in case they are applied.\n\"\"\",\n    )\n\n    assets: List[str] = Field(\n        default=[],\n        description=\"\"\"\nAssets relative to the contest directory that should be included while building\nthe statement. Files will be included in the same folder as the statement file.\nCan be glob pattern as well, such as `imgs/*.png`.\n\"\"\",\n    )\n\n    override: Optional[ProblemStatementOverride] = Field(\n        default=None, description='Override configuration for problem statements.'\n    )\n\n    # Vars to be re-used in the statement.\n    #   - It will be available as \\VAR{vars} variable in the contest-level box statement.\n    vars: Dict[str, Primitive] = Field(\n        {}, description='Variables to be re-used across the package.'\n    )\n\n    @property\n    def expanded_vars(self) -&gt; Dict[str, Primitive]:\n        return {key: expand_var(value) for key, value in self.vars.items()}\n</code></pre>"},{"location":"setters/reference/contest/schema/#rbx.box.contest.schema.ProblemStatementOverride","title":"<code>ProblemStatementOverride</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>configure</code> <code>List[Union[TexToPDF, JinjaTeX, rbxToTeX]]</code> <p>Configure how certain conversion steps should happen when applied to the statement file.</p> <p>Different from the <code>steps</code> field, this does not force the steps to happen, but rather only configure them in case they are applied.</p> <code>[]</code> Source code in <code>rbx/box/contest/schema.py</code> <pre><code>class ProblemStatementOverride(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    configure: List[ConversionStep] = Field(\n        [],\n        discriminator='type',\n        description=\"\"\"\nConfigure how certain conversion steps should happen when applied to the statement file.\n\nDifferent from the `steps` field, this does not force the steps to happen, but rather only\nconfigure them in case they are applied.\n\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/package/","title":"Problem package","text":"<p>This documentation goes over how each field (or group of fields) in <code>problem.rbx.yml</code> works.</p>"},{"location":"setters/reference/package/#problem-definition","title":"Problem definition","text":"<p>Schema: rbx.box.schema.Package</p> <p>The three main required fields in a <code>problem.rbx.yml</code> package are:</p> <ul> <li><code>name</code>: supports anything matching the regex <code>^[a-zA-Z0-9\\-]+$</code></li> <li><code>timeLimit</code>: the time limit of your problem, in milliseconds.</li> <li><code>memoryLimit</code>: the memory limit of your problem, in megabytes.</li> </ul> <p>A barebones package would look something like:</p> <pre><code>name: \"test-problem\"\ntimeLimit: 1000  # 1 second TL\nmemoryLimit: 256  # 256 MB ML\n</code></pre>"},{"location":"setters/reference/package/#language-modifiers","title":"Language Modifiers","text":"<p>You can add extra language-based limit modifiers to problems.</p> <pre><code>name: \"test-problem\"\ntimeLimit: 1000  # 1 second TL\nmemoryLimit: 256  # 256 MB ML\nmodifiers:\n  java:\n    time: 2000  # 2 second TL for Java\n    memory: 512  # 512 MB ML for Java\n</code></pre>"},{"location":"setters/reference/package/#checker","title":"Checker","text":"<p>Field: <code>checker</code> Schema: rbx.box.schema.CodeItem</p> <p>Checkers are also a very important part of your problem package, and define how the output of a solution will be judged.</p> <p>The checker is controlled through the top-level parameter <code>checker</code>, and is optional. In the case it is not specified, rbx falls back to testlib's wcmp.cpp, which is a token-based checker that compares the output of the solution with the expected answer.</p> <p>rbx is tightly integrated with testlib, and thus you can either specify:</p> <ol> <li> <p>The name of any checker in defined in testlib's checkers folder. The checker will be automatically downloaded when running solutions and building the package.</p> <pre><code>checker:\n  path: \"yesno.cpp\"\n</code></pre> <p>Tip</p> <p>If you want to explicitly download a checker from testlib, you can run <code>rbx download checker [name-of-the-checker]</code>.</p> </li> <li> <p>A custom testlib-based checker of your own, placed in the folder (or any sub-folder) of your package.</p> <pre><code>checker:\n  path: \"my-testlib-based-checker.cpp\"\n</code></pre> <p>Tip</p> <p>rbx automatically places <code>testlib.h</code> together with your code when compiling it, but you can explicitly download it with <code>rbx download testlib</code> if you want.</p> <p>Recommended</p> <p>This is usually the recommended solution when building a custom checker.</p> </li> <li> <p>A custom checker (not necessarily using testlib). It can even be in other language, in which case we suggest specifying the <code>language</code> property.</p> <pre><code>checker:\n  path: \"my-custom-checker.py\"\n  language: \"python\"\n</code></pre> <p>Note</p> <p>Although this is not a testlib-based checker, we still expect checker programs to follow the same command line structure as testlib, which is receiving and reading three file paths from the command line.</p> <p>Thus, your checker program will be called as <code>&lt;program&gt; &lt;input-file&gt; &lt;output-file&gt; &lt;expected-answer-file&gt;</code>.</p> </li> </ol>"},{"location":"setters/reference/package/#generators","title":"Generators","text":"<p>Field: <code>generators</code> Schema: <code>List[</code><code>Generator</code><code>]</code></p> <p>You can also specify a set of testcase generators that can be re-used in different places in your package (testgroup generation, stress tests to name a couple).</p> <p>Again, we encourage the use of testlib-based generators, but give you the flexibility to develop however you like.</p> <p>After implementing a generator, you can define it in <code>problem.rbx.yml</code> similar to how you define a checker, but you also have to name it to be able to reference it down the line.</p> <pre><code>generators:\n  - name: \"gen\"\n    path: \"my-gen.cpp\"\n</code></pre> <p>Notice also how the <code>generators</code> field is a list, and as such you can define multiple generators.</p>"},{"location":"setters/reference/package/#solutions","title":"Solutions","text":"<p>Field: <code>solutions</code> Schema: <code>List[</code><code>Solution</code><code>]</code></p> <p>You can specify multiple solutions to your problem, including incorrect ones to check that your testset is strong enough.</p> <p>You can define them similarly to generators and checkers, but you also have to provide an expected outcome for them.</p> <pre><code>solutions:\n  - path: \"sols/main.cpp\"\n    outcome: accepted\n  - path: \"sols/slow.cpp\"\n    outcome: tle\n  - path: \"sols/wa.cpp\"\n    outcome: wa\n</code></pre> <p>Also, you have to define an accepted solution. The first accepted solution in this list will be considered the main solution to generate answers for the testcases.</p> <p>For a full list of expected outcomes, see here.</p>"},{"location":"setters/reference/package/#testcase-groups","title":"Testcase groups","text":"<p>Field: <code>testcases</code> Schema: <code>List[</code><code>TestcaseGroup</code><code>]</code></p> <p>You can define multiple testgroups for you problem. For each testgroup, you can define tests for it in five (5) different ways:</p> <ol> <li> <p>Specifying a sequence of manually defined testcases present in your package's directory with the <code>testcases</code> field.</p> <pre><code>testcases:\n  - name: \"group-1\"\n    testcases:\n      - inputPath: \"manual-tests/1.in\"\n        outputPath: \"manual-tests/1.out\"\n      - inputPath: \"manual-tests/1.in\"\n</code></pre> <p>Note</p> <p>Notice how the <code>outputPath</code> is optional. If it is not defined, the main solution will be used to generate an output. This is the recommended approach.</p> </li> <li> <p>Specifying a glob of input paths with the <code>testcaseGlob</code> field.</p> <pre><code>testcases:\n  - name: \"group-1\"\n    testcaseGlob: \"tests/*.in\" # (1)!\n</code></pre> <ol> <li>Pick all files ending in <code>.in</code> inside the <code>tests/</code> folder as test inputs for     the testgroup. The files are taken in lexicographically increasing order.</li> </ol> </li> <li> <p>Specifying a list of generator calls with the <code>generators</code> field.</p> <pre><code>testcases:\n  - name: \"generated\"\n    generators:\n      - name: \"gen1\"\n        args: \"1000 30\"\n      - name: \"gen1\"\n        args: \"1000 42\"\n</code></pre> </li> <li> <p>Specifying a static generator script with the <code>generatorScript</code> field:</p> problem.rbx.ymlscript.txt <pre><code>testcases:\n  - name: \"generated\"\n    generatorScript:\n      path: \"script.txt\"\n</code></pre> <pre><code>gen 1000 30\ngen 1000 42\n# ...other tests\n</code></pre> <p>Note</p> <p>The <code>.txt</code> extension is necessary for rbx to identify this is a static script.</p> <p>Recommended</p> <p>This is usually the recommended approach to generate a few pre-defined testcases. Prefer this over the <code>generators</code> call to keep <code>problem.rbx.yml</code> cleaner.</p> </li> <li> <p>Specifying a dynamic generator script with the <code>generatorScript</code> field:</p> problem.rbx.ymlscript.py <pre><code>testcases:\n  - name: \"generated\"\n    generatorScript:\n      path: \"script.py\"\n</code></pre> <pre><code># Generates 10 different cases with different parameters.\nfor i in range(10):\n  print(f'gen 1000 {i}')\n</code></pre> <p>Recommended</p> <p>This is usually the recommended approach to generate multiple random testcases.</p> </li> </ol> <p>Warning</p> <p>If the platform you package the problem for does not support testgroups, tests will be flattened into a single group, and the tests will be executed in the order the groups were defined.</p>"},{"location":"setters/reference/package/#samples","title":"Samples","text":"<p>You can also specify samples to be included in your statement by defining a testgroup named <code>samples</code>. This testgroup has to be the first one defined, otherwise an error will be raised.</p>"},{"location":"setters/reference/package/#variables","title":"Variables","text":"<p>Field: <code>vars</code> Schema: <code>Dict[str, Union[str, int, float, bool]]</code></p> <p>In the package definition you can define variables that can be referenced in statements, validators and stress tests.</p> <p>This is useful to maintain consistency when changing constraints of your problem. A common mistake this field tries to solve is changing constraints in the statement, but not updating them in the validator.</p> <pre><code>vars:\n  MAX_N: 10000\n  MAX_A: 100000\n  MOD: py`10**9+7` # Backticks force the var to be evaluated as a Python expression.\n</code></pre> <p>Note</p> <p>Variable names should be valid Python identifiers.</p> <p>Tip</p> <p>You can see how to include these variables in each of the possible assets in the sections below.</p>"},{"location":"setters/reference/package/#validators","title":"Validators","text":"<p>Field: <code>validator</code>, <code>testcases.validator</code> Schema: rbx.box.schema.CodeItem</p> <p>You can specify testlib validators that check whether both manual and generated testcases are in the correct format.</p> <p>You can specify validators in two places:</p> <ol> <li> <p>In the package definition, through the <code>validator</code> field.</p> <pre><code>validator:\n  path: \"validator.cpp\"\n</code></pre> </li> <li> <p>In the testgroup definition, through the <code>validator</code> field, in which case this validator will be executed only for this group, and the package one will be ignored.</p> <pre><code>validator:\n  path: \"validator.cpp\"\ntestcases:\n  - name: \"group-with-usual-constraints\"\n    # ...other testgroup definitions\n  - name: \"group-with-different-constraints\"\n    # ...other testgroup definitions\n    validator:\n      path: \"validator-alternative.cpp\"\n</code></pre> </li> </ol> <p>You can pass variables to validators by calling testlib's <code>prepareOpts</code> function and by using its provided <code>opt</code> accessor.</p> <pre><code>#include \"testlib.h\"\n\nusing namespace std;\n\nint main(int argc, char *argv[]) {\n    registerValidation(argc, argv);\n    prepareOpts(argc, argv);\n\n    int MAX_N = opt&lt;int&gt;(\"MAX_N\"); // Read from package vars.\n\n    inf.readInt(1, MAX_N, \"N\");\n    inf.readEoln();\n    inf.readEof();\n}\n</code></pre>"},{"location":"setters/reference/package/#stress-tests","title":"Stress tests","text":"<p>Field: <code>stresses</code> Schema: <code>List[</code><code>Stress</code><code>]</code></p> <p>You can pre-define stress tests with a few applications in mind, such as:</p> <ul> <li>Finding testcases that break incorrect solutions;</li> <li>Ensuring solutions you expect to be correct cannot be broken.</li> </ul> <p>Let's break down each field in the stress test below:</p> <pre><code>stresses:\n  - name: \"stress1\"\n    generator:\n      name: \"gen\"\n      args: \"--MAX_N=[1..1000] @\"\n    finder: \"[sols/wa.cpp] ~ INCORRECT\"\n</code></pre> <ul> <li><code>name</code>: a name for the stress test. Useful when calling this test through <code>rbx stress [name]</code>.</li> <li><code>generator</code>: a generator to be repeatedly called in this stress test.</li> <li><code>name</code>: the name of the generator</li> <li><code>args</code>: args pattern to be passed to generator.<ul> <li>You can pass a random integer by writing something like <code>[1..1000]</code>.</li> <li>You can pass variables defined in the <code>vars</code> section with something like <code>&lt;MAX_N&gt;</code>.</li> <li>You can pass a random choice by writing something like <code>(a|b|c)</code>.</li> <li>You can pass a random hex string by passing <code>@</code>.</li> </ul> </li> <li><code>finder</code>: a finder expression that, when evaluated to true, consider the given generated test as a match</li> </ul>"},{"location":"setters/reference/package/#finder-expressions","title":"Finder expressions","text":"<p>Finder expressions are domain-specific expressions evaluated by rbx that helps you finding tests that meet certain conditions.</p> <p>Below, we list a few finder expressions, with an explanation on what they do. They should give a rough understanding of how this feature works.</p> <pre><code># Find a test for which `sols/wa.cpp` returns any verdict considered incorrect.\n[sols/wa.cpp] ~ INCORRECT\n\n# Find a test that fails one incorrect solution and a TLE solution at the same time.\n[sols/wa.cpp] ~ INCORRECT &amp;&amp; [sols/tle.cpp] ~ TLE\n\n# Find a test that fails one incorrect solution, but do not TLE other solution at the same time.\n[sols/wa.cpp] ~ INCORRECT &amp;&amp; [sols/tle.cpp] !~ TLE\n[sols/wa.cpp] ~ INCORRECT &amp;&amp; !([sols/tle.cpp] ~ TLE)\n\n# Find a test that fails one or the other.\n[sols/wa.cpp] ~ INCORRECT || [sols/wa2.cpp] ~ INCORRECT\n\n# Find a test where solutions give different verdicts.\n[sols/sol1.cpp] != [sols/sol2.cpp]\n\n# By using the ON syntax, specifies a custom checker to be used (instead of the main one).\n[sols/wa.cpp ON custom-checker.cpp] ~ INCORRECT\n\n# Use no checker whatsoever. Useful when you don't have a checker yet.\n[sols/tle.cpp ON :nil] ~ TLE\n\n# Use a 2-way checker. This checker will only require the input and the\n# output generated by the stressed program. In place of the output of the\n# main solution, an empty file will be passed.\n#\n# Useful if you don't have a main solution yet.\n[sols/wa.cpp ON 2:my_checker.cpp] ~ INCORRECT\n\n# Special operators:\n# Find a test that breaks the main solution (here, specified by a $).\n[$] ~ INCORRECT\n\n# Find a test that breaks the main solution, using the main checker in\n# a 2-way fashion.\n[$ ON 2:$] ~ INCORRECT\n</code></pre> <p>Finder expressions are really powerful, and can even be used to test your checkers, instead of solutionsthemselves.</p> <pre><code># Find a test where the checker returns something different than WA,\n# even though the given solution always WA.\n[sols/always-wa.cpp ON custom-checker.cpp] != WA\n\n# Compare two checkers to see if they're misbehaving.\n[sols/sol.cpp ON custom-checker.cpp] != [sols/sol.cpp ON brute-force-checker.cpp]\n</code></pre>"},{"location":"setters/reference/package/schema/","title":"Problem schema","text":""},{"location":"setters/reference/package/schema/#problemrbxyml","title":"<code>problem.rbx.yml</code>","text":""},{"location":"setters/reference/package/schema/#rbx.box.schema.CodeItem","title":"<code>CodeItem</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to the code file, relative to the package directory.</p> required <code>language</code> <code>str | None</code> <p>The language of the code file.</p> <code>None</code> <code>compilationFiles</code> <code>List[str] | None</code> <p>Extra files that should be placed alongside the code file during its compilation, such as testlib.h, jngen.h, etc.</p> <p>The paths should be given relative to the package directory, but will be included relative to the <code>path</code> directory.</p> <p>Testlib and jngen are already included by default.</p> <code>[]</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class CodeItem(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    path: pathlib.Path = Field(\n        description=\"\"\"The path to the code file, relative to the package directory.\"\"\"\n    )\n\n    language: Optional[str] = Field(\n        None, description=\"\"\"The language of the code file.\"\"\"\n    )\n\n    compilationFiles: Optional[List[str]] = Field(\n        [],\n        description=\"\"\"\nExtra files that should be placed alongside the code file during its compilation,\nsuch as testlib.h, jngen.h, etc.\n\nThe paths should be given relative to the package directory, but will be included\nrelative to the `path` directory.\n\nTestlib and jngen are already included by default.\n\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome","title":"<code>ExpectedOutcome</code>","text":"<p>               Bases: <code>AutoEnum</code></p> Source code in <code>rbx/box/schema.py</code> <pre><code>class ExpectedOutcome(AutoEnum):\n    ACCEPTED = alias('accepted', 'ac', 'correct')  # type: ignore\n    \"\"\"Expected outcome for correct solutions (AC).\"\"\"\n\n    WRONG_ANSWER = alias('wrong answer', 'wa')  # type: ignore\n    \"\"\"Expected outcome for solutions that finish successfully,\n    but the produced output are incorrect (WA).\"\"\"\n\n    INCORRECT = alias('fail', 'incorrect')  # type: ignore\n    \"\"\"Expected outcome for solutions that finish with any non-AC verdict.\"\"\"\n\n    RUNTIME_ERROR = alias('runtime error', 'rte', 're')  # type: ignore\n    \"\"\"Expected outcome solutions that finish with non-zero code (RTE).\"\"\"\n\n    TIME_LIMIT_EXCEEDED = alias('time limit exceeded', 'timeout', 'tle')  # type: ignore\n    \"\"\"Expected outcome for solutions that do not finish in time.\"\"\"\n\n    MEMORY_LIMIT_EXCEEDED = alias('memory limit exceeded', 'mle')  # type: ignore\n    \"\"\"Expected outcome for solutions that use more memory than allowed.\"\"\"\n\n    OUTPUT_LIMIT_EXCEEDED = alias('output limit exceeded', 'ole')  # type: ignore\n    \"\"\"Expected outcome for solutions that use more output than allowed.\"\"\"\n\n    TLE_OR_RTE = alias('tle or rte', 'tle/rte', 'tle+rte')  # type: ignore\n    \"\"\"Expected outcome for solutions that finish with either TLE or RTE.\n\n    Especially useful for environments where TLE and RTE are indistinguishable.\"\"\"\n\n    def style(self) -&gt; str:\n        if self == ExpectedOutcome.ACCEPTED:\n            return 'green'\n        if self == ExpectedOutcome.WRONG_ANSWER:\n            return 'red'\n        if self == ExpectedOutcome.INCORRECT:\n            return 'red'\n        if self.match(Outcome.TIME_LIMIT_EXCEEDED):\n            return 'yellow'\n        if self.match(Outcome.RUNTIME_ERROR):\n            return 'lnumber'\n        if self.match(Outcome.MEMORY_LIMIT_EXCEEDED):\n            return 'cyan'\n        return 'magenta'\n\n    def is_slow(self) -&gt; bool:\n        return self in [ExpectedOutcome.TIME_LIMIT_EXCEEDED, ExpectedOutcome.TLE_OR_RTE]\n\n    def match(self, outcome: Outcome) -&gt; bool:\n        if self == ExpectedOutcome.ACCEPTED:\n            return outcome == Outcome.ACCEPTED\n        if self == ExpectedOutcome.WRONG_ANSWER:\n            return outcome == Outcome.WRONG_ANSWER\n        if self == ExpectedOutcome.INCORRECT:\n            return outcome in {\n                Outcome.WRONG_ANSWER,\n                Outcome.RUNTIME_ERROR,\n                Outcome.MEMORY_LIMIT_EXCEEDED,\n                Outcome.TIME_LIMIT_EXCEEDED,\n                Outcome.OUTPUT_LIMIT_EXCEEDED,\n            }\n        if self == ExpectedOutcome.RUNTIME_ERROR:\n            return outcome == Outcome.RUNTIME_ERROR\n        if self == ExpectedOutcome.TIME_LIMIT_EXCEEDED:\n            return outcome == Outcome.TIME_LIMIT_EXCEEDED\n        if self == ExpectedOutcome.MEMORY_LIMIT_EXCEEDED:\n            return outcome == Outcome.MEMORY_LIMIT_EXCEEDED\n        if self == ExpectedOutcome.TLE_OR_RTE:\n            return outcome in {Outcome.TIME_LIMIT_EXCEEDED, Outcome.RUNTIME_ERROR}\n        if self == ExpectedOutcome.OUTPUT_LIMIT_EXCEEDED:\n            return outcome == Outcome.OUTPUT_LIMIT_EXCEEDED\n        return False\n\n    def get_matches(self) -&gt; List[Outcome]:\n        return [outcome for outcome in Outcome if self.match(outcome)]\n\n    def intersect(self, rhs: 'ExpectedOutcome') -&gt; bool:\n        return bool(set(self.get_matches()) &amp; set(rhs.get_matches()))\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.ACCEPTED","title":"<code>ACCEPTED = alias('accepted', 'ac', 'correct')</code>","text":"<p>Expected outcome for correct solutions (AC).</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.INCORRECT","title":"<code>INCORRECT = alias('fail', 'incorrect')</code>","text":"<p>Expected outcome for solutions that finish with any non-AC verdict.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.MEMORY_LIMIT_EXCEEDED","title":"<code>MEMORY_LIMIT_EXCEEDED = alias('memory limit exceeded', 'mle')</code>","text":"<p>Expected outcome for solutions that use more memory than allowed.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.OUTPUT_LIMIT_EXCEEDED","title":"<code>OUTPUT_LIMIT_EXCEEDED = alias('output limit exceeded', 'ole')</code>","text":"<p>Expected outcome for solutions that use more output than allowed.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.RUNTIME_ERROR","title":"<code>RUNTIME_ERROR = alias('runtime error', 'rte', 're')</code>","text":"<p>Expected outcome solutions that finish with non-zero code (RTE).</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.TIME_LIMIT_EXCEEDED","title":"<code>TIME_LIMIT_EXCEEDED = alias('time limit exceeded', 'timeout', 'tle')</code>","text":"<p>Expected outcome for solutions that do not finish in time.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.TLE_OR_RTE","title":"<code>TLE_OR_RTE = alias('tle or rte', 'tle/rte', 'tle+rte')</code>","text":"<p>Expected outcome for solutions that finish with either TLE or RTE.</p> <p>Especially useful for environments where TLE and RTE are indistinguishable.</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.ExpectedOutcome.WRONG_ANSWER","title":"<code>WRONG_ANSWER = alias('wrong answer', 'wa')</code>","text":"<p>Expected outcome for solutions that finish successfully, but the produced output are incorrect (WA).</p>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Generator","title":"<code>Generator</code>","text":"<p>               Bases: <code>CodeItem</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the generator.</p> required Source code in <code>rbx/box/schema.py</code> <pre><code>class Generator(CodeItem):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = NameField(description=\"\"\"The name of the generator.\"\"\")\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.GeneratorCall","title":"<code>GeneratorCall</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the generator to call.</p> required <code>args</code> <code>str | None</code> <p>The arguments to pass to the generator.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class GeneratorCall(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = NameField(description='The name of the generator to call.')\n\n    args: Optional[str] = Field(\n        None, description='The arguments to pass to the generator.'\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.LimitModifiers","title":"<code>LimitModifiers</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>timeMultiplier</code> <code>float | None</code> <p>Multiplier for time limit.</p> <code>None</code> <code>time</code> <code>int | None</code> <p>Value to override time limit with, in milliseconds.</p> <code>None</code> <code>memory</code> <code>int | None</code> <p>Value to override memory limit with, in MB.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class LimitModifiers(BaseModel):\n    timeMultiplier: Optional[float] = Field(\n        None, description='Multiplier for time limit.'\n    )\n    time: Optional[int] = Field(\n        None, description='Value to override time limit with, in milliseconds.'\n    )\n    memory: Optional[int] = Field(\n        None, description='Value to override memory limit with, in MB.'\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Package","title":"<code>Package</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the problem.</p> required <code>timeLimit</code> <code>int</code> <p>Time limit of the problem, in milliseconds.</p> required <code>memoryLimit</code> <code>int</code> <p>Memory limit of the problem, in MB.</p> required <code>outputLimit</code> <code>int</code> <p>Output limit of the problem, in KB.</p> <code>4096</code> <code>modifiers</code> <code>Dict[str, LimitModifiers]</code> <p>Limit modifiers that can be specified per language.</p> <code>{}</code> <code>checker</code> <code>CodeItem | None</code> <p>The checker for this problem.</p> <code>None</code> <code>validator</code> <code>CodeItem | None</code> <p>The validator for this problem.</p> <code>None</code> <code>generators</code> <code>List[Generator]</code> <p>Generators for this problem.</p> <code>[]</code> <code>solutions</code> <code>List[Solution]</code> <p>All tested solutions for this problem.</p> <p>The first solution in this list should be the main solution -- the one that is correct and used as reference -- and should have the <code>accepted</code> outcome.</p> <code>[]</code> <code>testcases</code> <code>List[TestcaseGroup]</code> <p>Testcases for the problem.</p> <code>[]</code> <code>stresses</code> <code>List[Stress]</code> <p>Stress tests for the problem.</p> <code>[]</code> <code>statements</code> <code>List[Statement]</code> <p>Statements for the problem.</p> <code>[]</code> <code>vars</code> <code>Dict[str, Union[str, int, float, bool]]</code> <p>Variables to be re-used across the package.</p> <code>{}</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class Package(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    # Name of the problem.\n    name: str = NameField(description='The name of the problem.')\n\n    timeLimit: int = Field(description='Time limit of the problem, in milliseconds.')\n\n    memoryLimit: int = Field(description='Memory limit of the problem, in MB.')\n\n    outputLimit: int = Field(\n        4 * 1024, description='Output limit of the problem, in KB.'\n    )\n\n    modifiers: Dict[str, LimitModifiers] = Field(\n        {},\n        description=\"\"\"\n    Limit modifiers that can be specified per language.\n    \"\"\",\n    )\n\n    checker: Optional[CodeItem] = Field(\n        None, description='The checker for this problem.'\n    )\n\n    validator: Optional[CodeItem] = Field(\n        None, description='The validator for this problem.'\n    )\n\n    generators: List[Generator] = Field([], description='Generators for this problem.')\n\n    solutions: List[Solution] = Field(\n        [],\n        description=\"\"\"\nAll tested solutions for this problem.\n\nThe first solution in this list should be the main solution -- the one\nthat is correct and used as reference -- and should have the `accepted` outcome.\n\"\"\",\n    )\n\n    testcases: List[TestcaseGroup] = Field([], description='Testcases for the problem.')\n\n    stresses: List[Stress] = Field([], description='Stress tests for the problem.')\n\n    statements: List[Statement] = Field([], description='Statements for the problem.')\n\n    # Vars to be re-used across the package.\n    #   - It will be passed as --key=value arguments to the validator.\n    #   - It will be available as \\VAR{key} variables in the rbx statement.\n    vars: Dict[str, Primitive] = Field(\n        {}, description='Variables to be re-used across the package.'\n    )\n\n    @property\n    def expanded_vars(self) -&gt; Dict[str, Primitive]:\n        return {key: expand_var(value) for key, value in self.vars.items()}\n\n    def timelimit_for_language(self, language: Optional[str]) -&gt; int:\n        res = self.timeLimit\n        if language is None:\n            return res\n        if language not in self.modifiers:\n            return res\n        modifier = self.modifiers[language]\n        if modifier.time is not None:\n            return modifier.time\n        if modifier.timeMultiplier is not None:\n            return int(res * float(modifier.timeMultiplier))\n        return res\n\n    def memorylimit_for_language(self, language: Optional[str]) -&gt; int:\n        res = self.memoryLimit\n        if language is None:\n            return res\n        if language not in self.modifiers:\n            return res\n        modifier = self.modifiers[language]\n        if modifier.memory is not None:\n            return modifier.memory\n        return res\n\n    @model_validator(mode='after')\n    def check_first_solution_is_main(self):\n        if self.solutions:\n            if self.solutions[0].outcome != ExpectedOutcome.ACCEPTED:\n                raise PydanticCustomError(\n                    'MISSING_MAIN_SOLUTION',\n                    'The first solution in the package must have the \"ACCEPTED\" outcome.',\n                )\n        return self\n\n    @model_validator(mode='after')\n    def samples_come_first(self):\n        for i, group in enumerate(self.testcases):\n            if group.name == 'samples' and i &gt; 0:\n                raise PydanticCustomError(\n                    'SAMPLES_NOT_FIRST',\n                    'The \"samples\" group must be the first group in the package, but is actually the {i}-th',\n                    {'i': i + 1},\n                )\n        return self\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Solution","title":"<code>Solution</code>","text":"<p>               Bases: <code>CodeItem</code></p> <p>Parameters:</p> Name Type Description Default <code>outcome</code> <code>ExpectedOutcome</code> <p>The expected outcome of this solution.</p> required Source code in <code>rbx/box/schema.py</code> <pre><code>class Solution(CodeItem):\n    model_config = ConfigDict(extra='forbid')\n\n    outcome: ExpectedOutcome = Field(\n        description=\"\"\"The expected outcome of this solution.\"\"\"\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Stress","title":"<code>Stress</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the stress test.</p> required <code>generator</code> <code>GeneratorCall</code> <p>Generator pattern to call during stress-test.</p> required <code>finder</code> <code>str</code> <p>Finder expression to be used to match against generated tests.</p> required Source code in <code>rbx/box/schema.py</code> <pre><code>class Stress(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = NameField(description='The name of the stress test.')\n\n    generator: GeneratorCall = Field(\n        description='Generator pattern to call during stress-test.'\n    )\n\n    finder: str = Field(\n        description='Finder expression to be used to match against generated tests.'\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.Testcase","title":"<code>Testcase</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>inputPath</code> <code>Path</code> <p>The path of the input file.</p> required <code>outputPath</code> <code>Path | None</code> <p>The path of the output file.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class Testcase(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    inputPath: pathlib.Path = Field(description=\"\"\"The path of the input file.\"\"\")\n\n    outputPath: Optional[pathlib.Path] = Field(\n        None, description=\"\"\"The path of the output file.\"\"\"\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.TestcaseGroup","title":"<code>TestcaseGroup</code>","text":"<p>               Bases: <code>TestcaseSubgroup</code></p> <p>Parameters:</p> Name Type Description Default <code>subgroups</code> <code>List[TestcaseSubgroup]</code> <p>A list of test subgroups to define for this group.</p> <code>[]</code> <code>validator</code> <code>CodeItem | None</code> <p>A validator to use to validate the testcases of this group. If not specified, will use the package-level validator. Useful in cases where the constraints vary across test groups.</p> <code>None</code> <code>weight</code> <code>float | None</code> <p>The weight of this group in the final score. Useful for problems that have points.</p> <code>1.0</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class TestcaseGroup(TestcaseSubgroup):\n    model_config = ConfigDict(extra='forbid')\n\n    subgroups: List[TestcaseSubgroup] = Field(\n        [],\n        description=\"\"\"\nA list of test subgroups to define for this group.\n        \"\"\",\n    )\n\n    validator: Optional[CodeItem] = Field(\n        None,\n        description=\"\"\"\nA validator to use to validate the testcases of this group.\nIf not specified, will use the package-level validator.\nUseful in cases where the constraints vary across test groups.\n\"\"\",\n    )\n\n    weight: Optional[float] = Field(\n        1.0,\n        description=\"\"\"\nThe weight of this group in the final score. Useful for\nproblems that have points.\n\"\"\",\n    )\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.schema.TestcaseSubgroup","title":"<code>TestcaseSubgroup</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the test group.</p> required <code>testcases</code> <code>List[Testcase]</code> <p>The path of testcases to add to this group, in the order they're defined.</p> <code>[]</code> <code>testcaseGlob</code> <code>str | None</code> <p>A Python glob that matches input file paths relative to the package directory. The globbed files should end with the extension \".in\", and their corresponding outputs, if defined, should have the same file name, but ending with \".out\".</p> <code>None</code> <code>generators</code> <code>List[GeneratorCall]</code> <p>A list of generators to call to generate testcases for this group.</p> <code>[]</code> <code>generatorScript</code> <code>CodeItem | None</code> <p>A generator script to call to generate testcases for this group.</p> <code>None</code> Source code in <code>rbx/box/schema.py</code> <pre><code>class TestcaseSubgroup(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    name: str = NameField(description='The name of the test group.')\n\n    testcases: List[Testcase] = Field(\n        [],\n        description=\"\"\"\nThe path of testcases to add to this group,\nin the order they're defined.\"\"\",\n    )\n\n    testcaseGlob: Optional[str] = Field(\n        None,\n        description=\"\"\"\nA Python glob that matches input file paths relative to the\npackage directory. The globbed files should end with the extension\n\".in\", and their corresponding outputs, if defined, should have the same file name,\nbut ending with \".out\".\n\"\"\",\n    )\n\n    generators: List[GeneratorCall] = Field(\n        [],\n        description=\"\"\"\nA list of generators to call to generate testcases for this group.\n\"\"\",\n    )\n\n    generatorScript: Optional[CodeItem] = Field(\n        None,\n        description=\"\"\"\nA generator script to call to generate testcases for this group.\n\"\"\",\n    )\n\n    @model_validator(mode='after')\n    def check_oneof(self) -&gt; 'TestcaseSubgroup':\n        _check_oneof(\n            self,\n            [\n                'testcases',\n                'testcaseGlob',\n                'generators',\n                'generatorScript',\n            ],\n        )\n        return self\n</code></pre>"},{"location":"setters/reference/package/schema/#statements","title":"Statements","text":""},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.Statement","title":"<code>Statement</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>title</code> <code>str</code> <p>Name of the problem, as it appears in the statement.</p> required <code>path</code> <code>Path</code> <p>Path to the input statement file.</p> required <code>type</code> <code>StatementType</code> <p>Type of the input statement file.</p> required <code>steps</code> <code>List[Union[TexToPDF, JinjaTeX, rbxToTeX]]</code> <p>Describes a sequence of conversion steps that should be applied to the statement file.</p> <p>Usually, it is not necessary to specify these, as they can be inferred from the input statement type and the output statement type, but you can use this to force certain conversion steps to happen.</p> <code>[]</code> <code>configure</code> <code>List[Union[TexToPDF, JinjaTeX, rbxToTeX]]</code> <p>Configure how certain conversion steps should happen when applied to the statement file.</p> <p>Different from the <code>steps</code> field, this does not force the steps to happen, but rather only configure them in case they are applied.</p> <code>[]</code> <code>assets</code> <code>List[str]</code> <p>Assets relative to the package directory that should be included while building the statement. Files will be included in the same folder as the statement file, preserving their relativeness. Can be glob pattern as well, such as <code>imgs/*.png</code>.</p> <code>[]</code> <code>language</code> <code>str</code> <p>Language this is statement is written in.</p> <code>'en'</code> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class Statement(BaseModel):\n    model_config = ConfigDict(extra='forbid')\n\n    title: str = Field(\n        description='Name of the problem, as it appears in the statement.'\n    )\n\n    path: pathlib.Path = Field(description='Path to the input statement file.')\n\n    type: StatementType = Field(description='Type of the input statement file.')\n\n    steps: List[ConversionStep] = Field(\n        [],\n        discriminator='type',\n        description=\"\"\"\nDescribes a sequence of conversion steps that should be applied to the statement file.\n\nUsually, it is not necessary to specify these, as they can be inferred from the\ninput statement type and the output statement type, but you can use this to force\ncertain conversion steps to happen.\n\"\"\",\n    )\n\n    configure: List[ConversionStep] = Field(\n        [],\n        discriminator='type',\n        description=\"\"\"\nConfigure how certain conversion steps should happen when applied to the statement file.\n\nDifferent from the `steps` field, this does not force the steps to happen, but rather only\nconfigure them in case they are applied.\n\"\"\",\n    )\n\n    assets: List[str] = Field(\n        [],\n        description=\"\"\"\nAssets relative to the package directory that should be included while building\nthe statement. Files will be included in the same folder as the statement file, preserving\ntheir relativeness. Can be glob pattern as well, such as `imgs/*.png`.\n\"\"\",\n    )\n\n    language: str = Field('en', description='Language this is statement is written in.')\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType","title":"<code>StatementType</code>","text":"<p>               Bases: <code>AutoEnum</code></p> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class StatementType(AutoEnum):\n    rbxTeX = alias('rbx-tex', 'rbx-tex', 'rbx')  # type: ignore\n    \"\"\"Statement written in rbxTeX format.\"\"\"\n\n    TeX = alias('tex')\n    \"\"\"Statement written in pure LaTeX format.\"\"\"\n\n    JinjaTeX = alias('jinja-tex')\n    \"\"\"Statement written in LaTeX format with Jinja2 expressions.\"\"\"\n\n    PDF = alias('pdf')\n    \"\"\"Statement is a PDF.\"\"\"\n\n    def get_file_suffix(self) -&gt; str:\n        if self == StatementType.TeX:\n            return '.tex'\n        if self == StatementType.rbxTeX:\n            return '.rbx.tex'\n        if self == StatementType.JinjaTeX:\n            return '.jinja.tex'\n        if self == StatementType.PDF:\n            return '.pdf'\n        raise ValueError(f'Unknown statement type: {self}')\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType.rbxTeX","title":"<code>rbxTeX = alias('rbx-tex', 'rbx-tex', 'rbx')</code>","text":"<p>Statement written in rbxTeX format.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType.TeX","title":"<code>TeX = alias('tex')</code>","text":"<p>Statement written in pure LaTeX format.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType.JinjaTeX","title":"<code>JinjaTeX = alias('jinja-tex')</code>","text":"<p>Statement written in LaTeX format with Jinja2 expressions.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.StatementType.PDF","title":"<code>PDF = alias('pdf')</code>","text":"<p>Statement is a PDF.</p>"},{"location":"setters/reference/package/schema/#conversion-nodes","title":"Conversion nodes","text":""},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.ConversionType","title":"<code>ConversionType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class ConversionType(str, Enum):\n    rbxToTex = 'rbx-tex'\n    \"\"\"Conversion from rbxTeX to LaTeX.\"\"\"\n\n    TexToPDF = 'tex2pdf'\n    \"\"\"Conversion from LaTeX to PDF using pdfLaTeX.\"\"\"\n\n    JinjaTeX = 'jinja-tex'\n    \"\"\"Conversion from LaTeX with Jinja2 expressions to LaTeX.\"\"\"\n\n    def __repr__(self):\n        return str.__repr__(self.value)\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.ConversionType.JinjaTeX","title":"<code>JinjaTeX = 'jinja-tex'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Conversion from LaTeX with Jinja2 expressions to LaTeX.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.ConversionType.TexToPDF","title":"<code>TexToPDF = 'tex2pdf'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Conversion from LaTeX to PDF using pdfLaTeX.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.ConversionType.rbxToTex","title":"<code>rbxToTex = 'rbx-tex'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Conversion from rbxTeX to LaTeX.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.JinjaTeX","title":"<code>JinjaTeX</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal[ConversionType]</code> required Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class JinjaTeX(BaseModel):\n    type: Literal[ConversionType.JinjaTeX]\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.JoinTexToPDF","title":"<code>JoinTexToPDF</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configures the joining of contest and problem texes to PDF.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal[JoinerType]</code> required Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class JoinTexToPDF(BaseModel):\n    \"\"\"Configures the joining of contest and problem texes to PDF.\"\"\"\n\n    type: Literal[JoinerType.TexToPDF]\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.JoinerType","title":"<code>JoinerType</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class JoinerType(str, Enum):\n    TexToPDF = 'tex2pdf'\n    \"\"\"Join contest tex and problem texs to PDF using pdfLaTeX.\"\"\"\n\n    def __repr__(self):\n        return str.__repr__(self.value)\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.JoinerType.TexToPDF","title":"<code>TexToPDF = 'tex2pdf'</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>Join contest tex and problem texs to PDF using pdfLaTeX.</p>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.TexToPDF","title":"<code>TexToPDF</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configures the conversion between LaTeX and PDF using pdfLaTeX.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal[ConversionType]</code> required Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class TexToPDF(BaseModel):\n    \"\"\"Configures the conversion between LaTeX and PDF using pdfLaTeX.\"\"\"\n\n    type: Literal[ConversionType.TexToPDF]\n</code></pre>"},{"location":"setters/reference/package/schema/#rbx.box.statements.schema.rbxToTeX","title":"<code>rbxToTeX</code>","text":"<p>               Bases: <code>BaseModel</code></p> <p>Configures the conversion between rbxTeX and LaTeX.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>Literal[ConversionType]</code> required <code>template</code> <code>Path</code> <p>Path to the template that should be used to render the rbx-tex blocks.</p> <code>PosixPath('template.rbx.tex')</code> Source code in <code>rbx/box/statements/schema.py</code> <pre><code>class rbxToTeX(BaseModel):\n    \"\"\"Configures the conversion between rbxTeX and LaTeX.\"\"\"\n\n    type: Literal[ConversionType.rbxToTex]\n\n    template: pathlib.Path = Field(\n        default=pathlib.Path('template.rbx.tex'),\n        description='Path to the template that should be used to render the rbx-tex blocks.',\n    )\n</code></pre>"}]}